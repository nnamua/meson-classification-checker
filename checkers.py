# SPDX-FileCopyrightText: 2021 Paul Aumann
#
# SPDX-License-Identifier: Apache-2.0

from __future__ import annotations
from log import Log
from multimethod import multimethod
import objects, inspect, templates, typing, util, typing
from buildfile import BuildFile, MesonException
from typing import List

from util import is_array_type, ismultimethod, get_methods, pretty_print_func, varname, red, green, get_parameter_combinations, get_type
from generators import FunctionGenerator, MethodGenerator, ReturnTypeGenerator

"""
The following checker classes execute different verification checks.
Whereas lines are generated by generators `generators.py`, these classes
are responsible for adding the lines to the buildfile and reporting results
back to the user.
"""

# Dont do usage checks with these Types (because they are EVERYWHERE, and there are no problems)
default_types = [ objects.Boolean, objects.String, objects.Number, objects.Array, typing.Dict ]

class TypeChecker:
    """Checks whether a type fulfills the classification"""

    def __init__(self, T, bf: BuildFile,
                    check_type_usages: bool = False,
                    check_return_usages: bool = False,
                    only_func_name: bool = False):
        self.T = T
        self.bf = bf
        self.check_type_usages = check_type_usages # Check usages of this type
        self.check_return_usages = check_return_usages # Check usages of return values of methods
        self.only_func_name = only_func_name # Only display the function name without parameter types

    def _check_methods(self):
        """Checks if an object of this type has all specified methods."""

        for name, mm in inspect.getmembers(self.T, predicate=ismultimethod):
            print(f"\tChecking method {self.T.__name__}.{name}:", )

            # Create object
            obj_template = templates.get_template(self.T, name=templates.OBJECT, special_templates_key=mm)

            # Check each method
            for method in get_methods(mm):
                return_type = get_type(inspect.signature(method).return_annotation)
                returncheck_required = return_type not in (typing.Any, type(None)) # Dont do returntype check if returntype is any or none
                """
                Since parameters can be optional, there are multiple combinations of parameters that
                need to be tested.
                """
                for parameter_combination in get_parameter_combinations(method):
                    lines = [f"obj = {obj_template}"]

                    # Generate lines for the method call
                    method_check = MethodGenerator(name, "obj", parameter_combination, special_templates_key=mm)

                    # Dont add a return variable if it is not required
                    return_var = varname() if returncheck_required else None
                    lines += method_check.generate_lines(return_var)

                    # Generate lines for a returntype check if required
                    returncheck_lines = []
                    if returncheck_required:
                        return_gen = ReturnTypeGenerator(return_type, return_var)
                        returncheck_lines += return_gen.generate_lines()
                    
                    # Run check!
                    error_line, error_msg = self.bf.check_lines(lines + returncheck_lines)
                    method_str = name if self.only_func_name else f"{self.T.__name__}.{pretty_print_func(name, parameter_combination)}"
                    # Error is caused by returncheck_lines
                    if error_line >= len(lines):
                        print(f"\t\t{red('FAILED')}  :: {method_str}")
                        print(f"\t\t-> Returntype Error: '{error_msg}'")
                        Log.failure()
                    # Error is caused by invocation lines
                    elif error_line >= 0:
                        print(f"\t\t{red('FAILED')}  :: {method_str}")
                        print(f"\t\t-> Invocation Error: '{error_msg}'")
                        Log.failure()
                        continue
                    # No error found!
                    else:
                        print(f"\t\t{green('SUCCESS')} :: {method_str}")
                        Log.success()
                        
                    # If required, also run a usage check for the returned value
                    if returncheck_required and self.check_return_usages:
                        usage_checker = UsageChecker(return_type, self.bf, return_var, lines)
                        usage_checker.run(msg_content="of return value")

    def run(self):
        """Runs specified checks for the given type."""
        # Check if methods are supported
        print(f"Checking type {self.T.__name__}:")
        self._check_methods()

        if not self.check_type_usages:
            return
        print("")
        # Check if object can be used everywhere it is supposed to
        obj_template  = templates.get_template(self.T)
        usage_checker = UsageChecker(self.T, self.bf, "obj", [f"obj = {obj_template}"], indent=1)
        usage_checker.run(msg_content="of type")

class FunctionChecker:
    """Checks whether a function fulfills the classification"""

    def __init__(self, func, bf: BuildFile,
                    check_return_usages: bool = False,
                    only_func_name: bool = False):
        self.func = func
        self.bf = bf
        self.check_return_usages = check_return_usages # Check usages of return value
        self.only_func_name = only_func_name # Only display the function name without parameter types

    def run(self):
        
        func_name = util.get_name(self.func)
        print(f"Checking {func_name}():")

        functions = get_methods(self.func) if isinstance(self.func, multimethod) else (self.func,)

        # Check each method
        for func in functions:
            return_type = get_type(inspect.signature(func).return_annotation)
            returncheck_required = return_type not in (typing.Any, type(None)) # Dont do returntype check if returntype is any or none
            """
            Since parameters can be optional, there are multiple combinations of parameters that
            need to be tested.
            """
            for parameter_combination in get_parameter_combinations(func):
                lines = []

                # Generate lines for the method call
                func_check = FunctionGenerator(func_name, parameter_combination, special_templates_key=self.func)

                # Check if function is project()-call (Requires special buildfile)
                is_project_func = func_name == "project"
                if is_project_func:
                    self.bf.push_content()

                # Dont add a return variable if it is not required
                return_var = varname() if returncheck_required else None
                lines += func_check.generate_lines(return_var, inline=is_project_func)

                # Generate lines for a returntype check if required
                returncheck_lines = []
                if returncheck_required:
                    return_gen = ReturnTypeGenerator(return_type, return_var)
                    returncheck_lines += return_gen.generate_lines()
                    
                # Run check!
                error_line, error_msg = self.bf.check_lines(lines + returncheck_lines)
                func_str = func_name if self.only_func_name else pretty_print_func(func_name, parameter_combination)
                # Error is caused by returncheck_lines
                if error_line >= len(lines):
                    print(f"\t{red('FAILED')}  :: {func_str}")
                    print(f"\t-> Returntype Error: '{error_msg}'")
                    Log.failure()
                # Error is caused by invocation lines
                elif error_line >= 0:
                    print(f"\t{red('FAILED')}  :: {func_str}")
                    print(f"\t-> Invocation Error: '{error_msg}'")
                    Log.failure()
                    continue
                # No error found!
                else:
                    print(f"\t{green('SUCCESS')} :: {func_str}")
                    Log.success()
                        
                # If required, also run a usage check for the returned value
                if returncheck_required and self.check_return_usages:
                    usage_checker = UsageChecker(return_type, self.bf, return_var, lines, indent=1)
                    usage_checker.run(msg_content="of return value")

                # If function is project(), restore buildfile
                if is_project_func:
                    self.bf.pop_content()

class UsageChecker:
    
    def __init__(self, T, bf: BuildFile,
                    obj_var: str,
                    prefix_lines: List[str],
                    indent: int = 2):
        self.T = T
        self.bf = bf
        self.obj_var = obj_var
        self.prefix_lines = prefix_lines
        
        self.indent = indent

    def _check_usage(self, callables, oftype=None):
        """Check if object of type can be used in function when parameter expects type"""

        for clb in callables:
            # Some functions might take an array of this type, so add an array that wraps this variable
            arr_var = varname()
            lines = [ f"{arr_var} = [{self.obj_var}]" ]
            func_name = util.get_name(clb)

            # clb might be a multimethod
            functions = get_methods(clb) if isinstance(clb, multimethod) else (clb,)
            for func in functions:
                for param_combination in util.get_parameter_combinations(func):
                    # Find out which parameters match the type and don't require a special template
                    matching_params = [ param for param in param_combination if
                                        # if T is subclass of annotation type or type is generic and T in generic type list
                                        (
                                            util.in_generic_types(param.annotation, self.T)
                                            or (
                                                # issubclass cannot be used with generic types
                                                typing.get_origin(param.annotation) not in (objects.Array, typing.Union)
                                                and typing.get_origin(self.T) not in (objects.Array, typing.Union)
                                                and util.is_subclass(self.T, param.annotation)
                                            )
                                        )
                                        # if method doesnt require special template for parameter
                                        and not templates.has_special_template(self.T, param.name, clb)]
                    
                    # Create existing_objects dict for functions, where they look up if an object already exists
                    # or a new one has to be made via templates
                    existing_objects = {param.name : arr_var if util.isarray(param.annotation) else self.obj_var for param in matching_params}

                    if len(matching_params) != 0:
                        # Create lines for a function call, using this object as an argument
                        if oftype != None:
                            method_obj_name = varname() # variable name for object
                            method_obj_template = templates.get_template(oftype, name=templates.OBJECT, special_templates_key=clb)
                            lines.append(f"{method_obj_name} = {method_obj_template}")
                            gen = MethodGenerator(func_name, method_obj_name, param_combination,
                                special_templates_key=clb,
                                existing_objects=existing_objects)
                        else:
                            gen = FunctionGenerator(func_name, param_combination,
                                special_templates_key=clb,
                                existing_objects=existing_objects)

                        lines += gen.generate_lines(None)

            # Run check for each function if lines have been added
            if len(lines) <= 1:
                continue
            # Run check!
            error_line, error_msg = self.bf.check_lines(self.prefix_lines + lines)
            print("\t" * (self.indent + 1), end="") # indent message
            if error_line >= 0:
                print(f"{red('FAILED')}  :: {func_name}() - {error_msg}")
                Log.failure()
            else:
                print(f"{green('SUCCESS')} :: {func_name}(){' ' * 4}")
                Log.success()

    def run(self, msg_content: str = ""):
        """Run usage checks on specified object."""
        # Skip usage check on built-in types like string and boolean
        if self.T not in default_types:
            print("\t" * self.indent, end="") # indent
            print(f"Checking usages {msg_content} in functions:")
            self._check_usage(util.get_functions())

            print("\t" * self.indent, end="") # indent
            print(f"Checking usages {msg_content} in methods:")
            # Check usage for every method of every object
            for obj in util.get_objects():
                methods = [m for name, m in inspect.getmembers(obj, predicate=util.ismultimethod)]
                self._check_usage(methods, oftype=obj)